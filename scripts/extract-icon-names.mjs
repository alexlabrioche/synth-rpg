#!/usr/bin/env node

/**
 * One-shot helper that walks the icon library and regenerates the
 * packages/specs/src/capabilities-catalog.ts file.
 */
import { randomUUID } from "node:crypto";
import { promises as fs } from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const ICONS_DIR = path.resolve(__dirname, "../apps/web/public/icons");
const OUTPUT_FILE = path.resolve(
  __dirname,
  "../packages/specs/src/capabilities-catalog.ts"
);
const I18N_DIR = path.resolve(__dirname, "../packages/specs/i18n");

const CATEGORY_MAP = {
  "audio-sources": "CapabilityCategory.Oscillator",
  "audio-modifiers": "CapabilityCategory.Fx",
  "cv-sources": "CapabilityCategory.Modulation",
  "cv-modifiers": "CapabilityCategory.Control",
};

const ALL_CATEGORIES = [
  "CapabilityCategory.Oscillator",
  "CapabilityCategory.Modulation",
  "CapabilityCategory.Fx",
  "CapabilityCategory.Control",
  "CapabilityCategory.Sequencer",
];

const LOCALES = [
  { filename: "en.json", labelFormatter: titleize },
  { filename: "fr.json", labelFormatter: titleize },
];

function titleize(slug) {
  return slug
    .split("-")
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join(" ");
}

function iconLabelKey(slug) {
  return `capabilities.${slug}.label`;
}

function iconDescriptionKey(slug) {
  return `capabilities.${slug}.description`;
}

async function collectCapabilities() {
  const dirents = await fs.readdir(ICONS_DIR, { withFileTypes: true });
  const capabilities = [];

  for (const dirent of dirents) {
    if (!dirent.isDirectory() || dirent.name.startsWith(".")) {
      continue;
    }

    const category = CATEGORY_MAP[dirent.name];

    if (!category) {
      throw new Error(
        `Missing category mapping for folder "${dirent.name}". Update CATEGORY_MAP in scripts/extract-icon-names.mjs`
      );
    }

    const iconDir = path.join(ICONS_DIR, dirent.name);
    const iconFiles = await fs.readdir(iconDir, { withFileTypes: true });

    for (const iconFile of iconFiles) {
      if (!iconFile.isFile() || iconFile.name.startsWith(".")) {
        continue;
      }

      const slug = path.parse(iconFile.name).name;

      capabilities.push({
        id: randomUUID(),
        slug,
        category,
        label: iconLabelKey(slug),
        description: iconDescriptionKey(slug),
      });
    }
  }

  return capabilities.sort((a, b) => a.slug.localeCompare(b.slug));
}

function formatCapability(capability, indent = "    ") {
  return `${indent}{
${indent}  id: "${capability.id}",
${indent}  slug: "${capability.slug}",
${indent}  category: ${capability.category},
${indent}  label: "${capability.label}",
${indent}  description: "${capability.description}",
${indent}}`;
}

function buildFileContent(capabilities) {
  const grouped = Object.fromEntries(
    ALL_CATEGORIES.map((category) => [category, []])
  );

  for (const capability of capabilities) {
    grouped[capability.category].push(capability);
  }

  const sections = ALL_CATEGORIES.map((category) => {
    const items = grouped[category]
      .map((capability) => formatCapability(capability, "    "))
      .join(",\n");

    const content = items ? `\n${items}\n  ` : "";

    return `  [${category}]: [${content}],`;
  }).join("\n");

  return `// This file is auto-generated by scripts/extract-icon-names.mjs
import type { Capability } from "@synth-rpg/types";
import { CapabilityCategory } from "@synth-rpg/types";

export const CAPABILITY_CATALOG: Record<CapabilityCategory, Capability[]> = {
${sections}
};

export const CAPABILITY_ARRAY: Capability[] = Object.values(
  CAPABILITY_CATALOG
).flat();
`;
}

function ensureLocaleData(raw) {
  const data = typeof raw === "object" && raw ? raw : {};
  const capabilities =
    typeof data.capabilities === "object" && data.capabilities
      ? data.capabilities
      : {};

  return { ...data, capabilities: { ...capabilities } };
}

async function updateTranslations(capabilities) {
  await fs.mkdir(I18N_DIR, { recursive: true });
  const slugs = capabilities.map((capability) => capability.slug);

  await Promise.all(
    LOCALES.map(async ({ filename, labelFormatter }) => {
      const filePath = path.join(I18N_DIR, filename);
      const existingContents = await fs
        .readFile(filePath, "utf8")
        .catch(() => "{}");
      const existing = ensureLocaleData(JSON.parse(existingContents));
      const entries = {};

      for (const slug of slugs) {
        const current = existing.capabilities[slug] ?? {};
        entries[slug] = {
          label: current.label ?? labelFormatter(slug),
          description: current.description ?? "",
        };
      }

      const nextData = {
        ...existing,
        capabilities: entries,
      };

      await fs.writeFile(
        filePath,
        `${JSON.stringify(nextData, null, 2)}\n`,
        "utf8"
      );
    })
  );
}

async function main() {
  const iconStats = await fs.stat(ICONS_DIR).catch(() => null);

  if (!iconStats?.isDirectory()) {
    throw new Error(`Icons directory not found at ${ICONS_DIR}`);
  }

  const capabilities = await collectCapabilities();
  const fileContent = buildFileContent(capabilities);

  await fs.mkdir(path.dirname(OUTPUT_FILE), { recursive: true });
  await fs.writeFile(OUTPUT_FILE, fileContent, "utf8");
  await updateTranslations(capabilities);

  console.log(
    `Generated ${capabilities.length} capabilities in ${path.relative(
      process.cwd(),
      OUTPUT_FILE
    )}`
  );
}

main().catch((error) => {
  console.error(error);
  process.exit(1);
});
